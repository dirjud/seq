<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Detach Example &mdash; seq v1 documentation</title>
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '1',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="seq v1 documentation" href="index.html" />
    <link rel="next" title="API" href="api.html" />
    <link rel="prev" title="FIR Filter Example" href="fir_example.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             accesskey="M">modules</a> |</li>
        <li class="right" >
          <a href="api.html" title="API"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="fir_example.html" title="FIR Filter Example"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">seq v1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="detach-example">
<h1>Detach Example<a class="headerlink" href="#detach-example" title="Permalink to this headline">Â¶</a></h1>
<p>This example shows how to use the <tt class="docutils literal"><span class="pre">detach</span></tt> keyword option an a child
sequence to allow it to run optionally in parallel to children from
other bins.  In this example we have a stream of data coming from a
data source that bursts a chunk of data that needs buffered for a read
source that runs at a slower burst rate. To deal with this we take a
chunk of memory and divide in two. Initially we give the lower half
to the capture device to burst data into. When it has filled the
lower half, we then want the read source to take over the lower half
and give the upper to the capture source to use. We want the option
of making memory access simultaneous or not. When the capture and
read source are done, we want to swap the buffers again and repeat
swapping buffers.</p>
<p>Here is the <tt class="docutils literal"><span class="pre">seq</span></tt> code that impliments this double buffer memory
access controller that contains an input port called <tt class="docutils literal"><span class="pre">detach</span></tt> that
controls whether memory access is simultaneously or not.</p>
<div class="highlight-python"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69</pre></div></td><td class="code"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">seq</span>
<span class="kn">from</span> <span class="nn">seq</span> <span class="kn">import</span> <span class="n">Bin</span><span class="p">,</span> <span class="n">Sequence</span> <span class="k">as</span> <span class="n">Seq</span>

<span class="c"># inputs</span>
<span class="n">detach</span>       <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">Signal</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;detach&quot;</span><span class="p">,</span>          <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">read_running</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">Signal</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;read_running&quot;</span><span class="p">,</span>    <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">read_done</span>    <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">Signal</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;read_done&quot;</span><span class="p">,</span>       <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">write_done</span>   <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">Signal</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;write_done&quot;</span><span class="p">,</span>      <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c"># output registers</span>
<span class="n">write_ptr</span>    <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">Signal</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;write_ptr&quot;</span><span class="p">,</span>       <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">read_ptr</span>     <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">Signal</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;read_ptr&quot;</span><span class="p">,</span>        <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">write_mode</span>   <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">Signal</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;write_mode&quot;</span><span class="p">,</span>      <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">read_mode</span>    <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">Signal</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;read_mode&quot;</span><span class="p">,</span>       <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">buf_swap</span>     <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">Signal</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;buffers_swapped&quot;</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">capture</span><span class="o">=</span> <span class="n">Bin</span><span class="o">.</span><span class="n">Bin</span><span class="p">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;capture_buf&quot;</span><span class="p">,</span>
    <span class="n">regs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">write_ptr</span><span class="p">,</span> <span class="n">read_ptr</span><span class="p">,</span> <span class="n">write_mode</span><span class="p">,</span> <span class="n">buf_swap</span> <span class="p">],</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="n">seqs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">Seq</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s">&quot;capture&quot;</span><span class="p">,</span>
            <span class="n">subseqs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">Seq</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="nb">set</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">write_mode</span><span class="o">=</span><span class="mi">1</span><span class="p">)),</span>
                        <span class="n">Seq</span><span class="o">.</span><span class="n">Sync</span><span class="p">(</span><span class="n">sync</span><span class="o">=</span><span class="n">write_done</span><span class="p">),</span>
                        <span class="n">Seq</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="nb">set</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">write_mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
                        <span class="p">]</span>
                   <span class="p">),</span>
        <span class="n">Seq</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s">&quot;sync_then_buf_swap&quot;</span><span class="p">,</span>
            <span class="n">subseqs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">Seq</span><span class="o">.</span><span class="n">Sync</span><span class="p">(</span><span class="n">sync</span><span class="o">=</span><span class="n">read_running</span><span class="p">,</span> <span class="n">active_high</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span>
                        <span class="n">Seq</span><span class="o">.</span><span class="n">Trigger</span><span class="p">(</span><span class="n">reg</span><span class="o">=</span><span class="s">&quot;buffers_swapped&quot;</span><span class="p">),</span>
                        <span class="n">Seq</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span><span class="n">subseqs</span><span class="o">=</span><span class="p">[</span><span class="n">Seq</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="nb">set</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">read_ptr</span><span class="o">=</span><span class="n">write_ptr</span><span class="p">)),</span>
                                            <span class="n">Seq</span><span class="o">.</span><span class="n">Toggle</span><span class="p">(</span><span class="n">reg</span><span class="o">=</span><span class="s">&quot;write_ptr&quot;</span><span class="p">),]),</span>
                        <span class="p">]</span>
            <span class="p">)</span>
        <span class="p">]</span>
    <span class="p">)</span>

<span class="n">read</span><span class="o">=</span> <span class="n">Bin</span><span class="o">.</span><span class="n">Bin</span><span class="p">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;read_buf&quot;</span><span class="p">,</span>
    <span class="n">register_done</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="n">regs</span> <span class="o">=</span> <span class="p">[</span> <span class="n">read_mode</span><span class="p">,</span> <span class="p">],</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="n">seqs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">Seq</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;read&quot;</span><span class="p">,</span> 
                   <span class="n">subseqs</span><span class="o">=</span><span class="p">[</span> <span class="n">Seq</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="nb">set</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">read_mode</span><span class="o">=</span><span class="mi">1</span><span class="p">)),</span>
                             <span class="n">Seq</span><span class="o">.</span><span class="n">Sync</span><span class="p">(</span><span class="n">sync</span><span class="o">=</span><span class="n">read_done</span><span class="p">),</span>
                             <span class="n">Seq</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="nb">set</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">read_mode</span><span class="o">=</span><span class="mi">0</span><span class="p">)),</span>
                             <span class="p">],</span>
                   <span class="n">running</span><span class="o">=</span><span class="n">read_running</span><span class="p">,</span> <span class="c"># export running signal as the sync</span>
                   <span class="p">),</span>
        <span class="p">],</span>
    <span class="p">)</span>

<span class="n">buf</span> <span class="o">=</span> <span class="n">Bin</span><span class="o">.</span><span class="n">Bin</span><span class="p">(</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">&quot;buf_ctl&quot;</span><span class="p">,</span>
    <span class="n">regs</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">read</span><span class="p">,</span> <span class="n">capture</span><span class="p">,],</span>
    <span class="n">seqs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">Seq</span><span class="o">.</span><span class="n">Serial</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">&quot;buf&quot;</span><span class="p">,</span> 
                   <span class="n">subseqs</span><span class="o">=</span><span class="p">[</span> <span class="s">&quot;capture&quot;</span><span class="p">,</span> 
                             <span class="s">&quot;sync_then_buf_swap&quot;</span><span class="p">,</span> 
                             <span class="n">Seq</span><span class="o">.</span><span class="n">Child</span><span class="p">(</span><span class="n">sequence</span><span class="o">=</span><span class="s">&quot;read&quot;</span><span class="p">,</span> <span class="n">detach</span><span class="o">=</span><span class="n">detach</span><span class="p">),</span> <span class="p">]),</span>
        <span class="p">],</span>
    <span class="p">)</span>

<span class="n">buf</span><span class="o">.</span><span class="n">vlog_dump</span><span class="p">(</span><span class="n">recurse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># create verilog</span>
<span class="n">buf</span><span class="o">.</span><span class="n">vlog_gen_instance</span><span class="p">()</span>     <span class="c"># create a verilog instantatiation</span>
</pre></div>
</td></tr></table></div>
<p>The hierarch for this controller is that the <tt class="docutils literal"><span class="pre">capture_buf</span></tt> and <tt class="docutils literal"><span class="pre">read_buf</span></tt>
bin are children of the <tt class="docutils literal"><span class="pre">buf_ctl</span></tt> bin.:</p>
<div class="highlight-python"><pre>         +---------------+
         |    buf_ctl    |
         +---------------+
            /         \
           /           \
+---------------+  +---------------+
|  capture_buf  |  |   read_buf    |
+---------------+  +---------------+</pre>
</div>
<p>Let&#8217;s take a top down approach in explaining this example by starting
with the buf_ctrl bin as defined in lines 56-66. The buf_ctl bin does
not control any registers directly (line 58) but is in control of the
read and capture bins (line 59). It has one Serial sequence (lines 61)
that executes three child sequence: &#8220;capture&#8221;, &#8220;sync_then_buf_swap&#8221;,
and &#8220;read&#8221;. This is a pretty good verbal description of what we want
to have happen. First we want to capture a buffer (&#8220;capture&#8221;), then we
want to wait for any read than might be occuring in parallel from the
previous capture (&#8220;sync&#8221;). Once we are sync&#8217;d, we can swap the buffer
pointers (&#8220;then_buf_swap&#8221;). With the buffer pointers swapped, we can
kick off a the read (&#8220;read&#8221;).</p>
<p>Notice that the &#8220;read&#8221; instantiation on line 64 is uses the <tt class="docutils literal"><span class="pre">detach</span></tt>
key word and hooks it up the the detach signal, which becomes an
import port. If detach is not low, then the &#8220;read&#8221; sequence will run
to completion, otherwise, the &#8220;read&#8221; sequence will get kicked off in
the background and the sequence will return immediately. If the
buf_ctl is run in a loop, then when detached, a &#8220;capture&#8221; sequence
will start up while the &#8220;read&#8221; sequence is still running. Then, if the
capture sequence is longer, the sync condition of the
&#8220;sync_then_buf_swap&#8221; will be true and there will be no waiting,
otherwise if the &#8220;read&#8221; is still occuring when the &#8220;capture&#8221;
completes, the &#8220;sync_then_buf_swap&#8221; will stall until the &#8220;read&#8221; is
complete. It will then swap buffer pointers and process with the
read. If the read was not detached, then the read will be complete
when entering the sync state and it will exit immediately. In this
way, the access to the memory can be controlled to be simultaneous or
not.</p>
<p>In order for two child processes to run simultaneous, they must
be in different bins. This is why the &#8220;capture&#8221; and &#8220;sync_then_buf_swap&#8221;
sequences are in a different bin than the &#8220;read&#8221; sequence. This allows
the &#8220;capture&#8221; and &#8220;sync_then_buf_swap&#8221; to run at the same time as the
&#8220;read&#8221; sequence.</p>
<p>Now let&#8217;s look at the &#8220;capture_buf&#8221; bin (lines 17-38). This bin
controls 4 registers that get exported as outputs. The &#8220;write_ptr&#8221; and
&#8220;read_ptr&#8221; are single bit signals that tell the capture and read
modules which half of the memory they have access to. The &#8220;write_mode&#8221;
register is a signal to the capture device that it can write to the
buffer specified by write_ptr.  The &#8220;buf_swap&#8221; register gets turned
into a trigger that fires whenever the buffers swap. In this example
it is purely used for informational purposes.</p>
<p>The &#8220;capture_buf&#8221; bin has two sequences. The first is called &#8220;capture&#8221;
(lines 22-28). This serial sequence uses three embedded sequences that
set the &#8220;write_mode&#8221; high (line 24), then wait for the capture device
to send back the sync signal &#8220;write_done&#8221; (line 25), and then drops
the &#8220;write_mode&#8221; signal so that the write device can wait for its next
opportunity.</p>
<p>The &#8220;sync_then_buf_swap&#8221; is a also a serial sequence that first waits
for the read to stop running (line 31), then triggers the &#8220;buffers_swapped&#8221;
signal, then swaps the &#8220;read_ptr&#8221; and &#8220;write_ptr&#8221; and completes.</p>
<p>THe &#8220;read&#8221; bin contains a single &#8220;read&#8221; sequence which is identical in
nature to the &#8220;capture&#8221; sequence except that its &#8220;running&#8221; state is
exported to the &#8220;read_running&#8221; signal so that the &#8220;sync_then_buf_swap&#8221;
can know sync to it.</p>
<p>Here is a timing diamgram of this controller in action:</p>
<img alt="_images/example_buf_ctl.png" src="_images/example_buf_ctl.png" />
<p>The pink shaded portions show the &#8220;write_mode&#8221; and &#8220;read_mode&#8221; signals
when detach is low. You can see that access to the memory is
synchronized. When detach goes high as shown in the green shaded
portions, you can see that as soon as data is available to the read
device, that access to the memory is simultaneous. In this example,
the read device takes about two time longer than the capture device,
and as shown the capture device always waits for the read to finish
before buffers are swapped.</p>
<p>The top level test bench that was used to generate this simulation
is as follows:</p>
<div class="highlight-python"><pre>module buf_ctl_tb();
   
   reg clk, reset_n, start, detach, read_done, write_done;
   wire read_ptr, write_ptr, read_mode, write_mode, buffers_swapped, running, done;
   always #1 clk = !clk;
   
   initial begin
      clk = 0;
      reset_n = 0;
      start = 0;
      detach = 0;
      write_done = 0;
      read_done = 0;

      $dumpfile("buf_ctl.vcd");
      $dumpvars(0, buf_ctl_tb);
      
      repeat(4) @(posedge clk);
      reset_n = 1;
      repeat(4) @(posedge clk);

      run();
      run();
      @(posedge clk) detach=1;
      @(posedge clk);
      run();
      run();
      run();
      $finish;
   end

   task run; // run a buffer through
      begin
	 @(posedge clk) start &lt;= 1;
	 @(posedge clk) start &lt;= 0;
	 @(posedge clk);
	 while(running) @(posedge clk);
      end
   endtask

   reg [7:0] mem[0:511]; //Shared memory buffer.

   /************************* A Capture Device ******************************/
   reg 	     capture_state;
   reg [8:0] capture_count;
   reg [7:0] capture_xin;
   always @(posedge clk or negedge reset_n) begin
      if(!reset_n) begin
	 capture_state &lt;= 0;
	 capture_count &lt;= 0;
	 write_done    &lt;= 0;
      end else begin
	 case(capture_state)
	   0: begin
	      if(write_mode &amp;&amp; !write_done) capture_state &lt;= 1;
	      capture_count &lt;= 0;
	      write_done    &lt;= 0;
	   end

	   1: begin
	      if(capture_count == 255) begin
		 capture_state &lt;= 0;
		 write_done &lt;= 1;
	      end
	      capture_count &lt;= capture_count + 1;
	      capture_xin = $random;
	      if(write_ptr) begin //when write_ptr is 1, we get top half of mem
		 mem[capture_count+256] &lt;= capture_xin;
	      end else begin // otherwise we use the lower half of the mem
		 mem[capture_count+000] &lt;= capture_xin;
	      end
	      $display("capture, val=%d, addr=%d, ptr=%d", capture_xin, capture_count, write_ptr);
	   end
	   
	 endcase
      end
   end
   /*************************************************************************/

   /************************* A Read Device ******************************/
   reg 	     read_state;
   reg [8:0] read_count;
   reg 	     randbit; // randomly controls when we can read. When high, we read, otherwise we wait. simulates a device that can randomly read from memory.
   always @(posedge clk or negedge reset_n) begin
      if(!reset_n) begin
	 read_state &lt;= 0;
	 read_done  &lt;= 0;
	 randbit    &lt;= 0;
      end else begin
	 randbit &lt;= $random;
	 case(read_state)
	   0: begin
	      if(read_mode &amp;&amp; !read_done) read_state &lt;= 1;
	      read_count &lt;= 0;
	      read_done  &lt;= 0;
	   end

	   1: begin
	      if(randbit) begin
		 if(read_count == 255) begin
		    read_state &lt;= 0;
		    read_done &lt;= 1;
		 end
		 
		 read_count &lt;= read_count + 1;
		 if(read_ptr) begin //when read_ptr is 1, we get top half of mem
		    $display("read, val=%d, addr=%d, ptr=%d", mem[read_count+256], read_count, read_ptr);
		 end else begin // otherwise we use the lower half of the mem
		    $display("read, val=%d, addr=%d. ptr=%d", mem[read_count], read_count, read_ptr);
		 end
	      end
	   end
	 endcase
      end
   end
   /*************************************************************************/

   always @(posedge clk) begin
      if(buffers_swapped) begin
	 $display("buffered swapped");
      end
   end
   
   buf_ctl u_buf_ctl_
     (.clk(clk),
      .reset_n(reset_n),

      // inputs
      .start(start),
      .seq(1'b0),
      .detach(detach),
      .write_done(write_done),
      .read_done(read_done),

      // outputs
      .read_ptr(read_ptr),
      .write_ptr(write_ptr),
      .read_mode(read_mode),
      .write_mode(write_mode),
      .buffers_swapped(buffers_swapped),
      .read_running(),
      .running(running),
      .done(done)
     );

endmodule</pre>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
            <h4>Previous topic</h4>
            <p class="topless"><a href="fir_example.html"
                                  title="previous chapter">FIR Filter Example</a></p>
            <h4>Next topic</h4>
            <p class="topless"><a href="api.html"
                                  title="next chapter">API</a></p>
            <h3>This Page</h3>
            <ul class="this-page-menu">
              <li><a href="_sources/example_buf_ctl.txt"
                     rel="nofollow">Show Source</a></li>
            </ul>
          <div id="searchbox" style="display: none">
            <h3>Quick search</h3>
              <form class="search" action="search.html" method="get">
                <input type="text" name="q" size="18" />
                <input type="submit" value="Go" />
                <input type="hidden" name="check_keywords" value="yes" />
                <input type="hidden" name="area" value="default" />
              </form>
              <p class="searchtip" style="font-size: 90%">
              Enter search terms or a module, class or function name.
              </p>
          </div>
          <script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="modindex.html" title="Global Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="api.html" title="API"
             >next</a> |</li>
        <li class="right" >
          <a href="fir_example.html" title="FIR Filter Example"
             >previous</a> |</li>
        <li><a href="index.html">seq v1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
      &copy; Copyright 2010, Lane Brooks.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 0.6.6.
    </div>
  </body>
</html>
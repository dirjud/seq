import seq
from seq import Bin, Sequence as Seq
import nitro

class Set(Seq.Set):
    """This Sequence extends the Seq.Set Sequence and will swap a
static 'set' dict out for a completely programmable one whose
default settings are the original static dict.  If a value in
the set dict is not an int, then it is not swapped and left
as is.

Example:

    Set(terminal=term, name="progA", set=dict(x=1, y=0, z=10))

This will add the following register to the 'terminal' terminal:
    Register(name="progA",
             type="int",
             mode="write",
             subregs=[ SubReg(name="x", init=1,  width=1, comment=""),
                       SubReg(name="y", init=0,  width=1, comment=""),
                       SubReg(name="z", init=10, width=4, comment=""),
                       ],
             ),

and then create a Set sequence of the form:
           
    Seq.Set(name="progA", set=dict(x=reg2sig(term["progA"]["x"]), 
                                   y=reg2sig(term["progA"]["y"]), 
                                   z=reg2sig(term["progA"]["z"])))

Any set values not of type int will not be swapped, so the following will work:

    Set("progB", set=dict(x=1, y=seq.Signal("my_own_y"), z=10))

This adds the following to the DI file:

    Register(name="progB",
             type="int",
             mode="write",
             subregs=[ SubReg(name="x", init=1, width=1, comment=""),
                       SubReg(name="z", init=10,width=12, comment=""),
                       ],
             ),
"""
    def __init__(self, terminal, name, set, **kw):
        """
:param terminal:  A nitro terminal object
:param name:  The name of this Sequence and the name of the register created in the terminal. 
:param set:   See Seq.Set documentation
"""
        kw["name"] = name
        self.init = set
        self.terminal = terminal
        self.di_reg_name = name
        newset = {}

        self.dont_swap = []
        for k,v in set.items():
            if type(v) is int:
                # swap out the ints for seq.Signals
                newset[k] = seq.Signal(name="%s_%s" % (self.di_reg_name, k,)) # width will get set correctly during linking
            else:
                self.dont_swap.append(k)
                newset[k] = v

        Seq.Set.__init__(self, newset, **kw)

    def link(self, bin, parent, data):
        subregs = []
        for k,v in self._set.items():
            if k in self.dont_swap: continue
            reg = bin.get_reg(k)
            subregs.append(nitro.SubReg(name=k, init=self.init[k], width=reg.width, comment=""))
            v.width = reg.width

        if subregs:
            self.terminal.add_child(nitro.Register(name=self.di_reg_name, comment="Autogenerated Set register", type="int", mode="write", subregs=subregs))

        Seq.Set.link(self, bin, parent, data)
                             

class Serial(Seq.Serial):
    """This Sequence extends the Seq.Serial Sequence and will swap a
static serial sequence out for a completely programmable one whose
default settings are the original static sequence.  It adds registers
to the terminal as necessary.  See Seq.Serial params.  A
termination register will be automatically added with a suffix '_stop_num'
in the  terminal list.  Set this to the number of the last register
is used by this sequence to know when to terminate."""
    def __init__(self, terminal, name, subseqs, set={}, extra=0, **kw):
        """:param extra: int. Number of extra sequences to append to the end of this sequence.
All other params are the same as the Seq.Serial Sequence"""

        kw["name"] = name
        self.init = subseqs
        self.di_reg_name = name
        self.terminal = terminal
        newsubseqs = []

        # create the termination Signal
        terminate = seq.Signal(name="%s_term_num" % (self.di_reg_name,), width=seq.calc_width(len(subseqs)+extra), init=len(subseqs)-1)

        for i, subseq in enumerate(subseqs):
            if not(type(subseq) is str):
                raise Exception("Cannot make Sequence %s programmable.  Only strings accepted in subseqs list. You provided a type=%s" % (str(subseq),type(subseq)))
            
            # swap out the strings for Signals
            psig = seq.Signal(name="%s_%s%d" % (self.di_reg_name, self.di_reg_name, i,), width=1)# correct width is set during linking
            pseq = Seq.Child(sequence=psig)
            newsubseqs.append(pseq)

        for j in range(extra): # append any extra sequences specified
            i+=1
            newsubseqs.append(Seq.Child(sequence=seq.Signal(name="%s_%s%d" % (self.di_reg_name, self.di_reg_name, i,), width=1)))
            self.init.append(0) # append address 0 as the initial condition for the extra registers

        Seq.Serial.__init__(self, subseqs=newsubseqs, set=set, term=terminate, **kw)

    def link(self, bin, parent, data):
        # calculate the width of the programmable sequence
        if(len(bin.children) <= 1):
            self.bin_addr_width = 0
        else:
            self.bin_addr_width = int(seq.calc_width(len(bin.children)))

        self.sequence_addr_width=1
        for child in bin.children:
            w = int(seq.calc_width(len(child.seqs)))
            if(w > self.sequence_addr_width): self.sequence_addr_width = w

        # now that we know the size necessary for each program
        # register, generate a value map so we can program these
        # registers by name
        self.valuemap = {}
        for j, child in enumerate(bin.children):
            for i, child_seq in enumerate(child.seqs):
                self.valuemap[child_seq.name] = (j << self.sequence_addr_width) + i

        self.sig_width = self.bin_addr_width + self.sequence_addr_width
        subregs = []
        for i, sig in enumerate(self.subseqs):
            s = sig.child_seq
            s.width = self.sig_width
            subregs.append(nitro.SubReg(name=self.di_reg_name+str(i),
                                        init=self.init[i],
                                        width=self.sig_width,
                                        valuemap=self.valuemap,
                                        comment=""))

        subregs.append(nitro.SubReg(name="term_num", 
                                    width=self.term.width,
                                    init=self.term.init,
                                    comment="Autogenerated sequencer termination register for %s Sequence.  This number controls how many Sequences are executed" % (self.name,), 
                                    ))


        reg = nitro.Register(name=self.di_reg_name, 
                             comment="Autogenerated programmable sequences control for  Serial %s Sequence" % (self.name,), 
                             type="int", 
                             mode="write", 
                             subregs = subregs,
                             )

        self.terminal.add_child(reg)
        Seq.Serial.link(self, bin, parent, data)

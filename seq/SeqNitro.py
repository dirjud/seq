from Sequencer import Sequencer
from Sequencer import Sequence as Seq
from Sequencer import Signal
from devlib import DeviceInterface as DI
import hydro

class SetDI(Seq.Set):
    """This Sequence extends the Seq.Set Sequence and will swap a
static 'set' dict out for a completely programmable one whose
default settings are the original static dict.  If a value in
the set dict is not an int, then it is not swapped and left
as is.

Example:

    SeqDI.SetDI(name="progA", set=dict(x=1, y=0, z=10))

Is equivalent to:

    Seq.Set(name="progA", set=dict(x=i2c["progA_x"], y=i2c["progA_y"], z=i2c["progA_z"]))

with the following in your DI file:

    Register(name="progA",
             type="int",
             mode="write",
             subregs=[ SubReg(name="x", init=1, width=1, comment=""),
                       SubReg(name="y", init=0, width=1, comment=""),
                       SubReg(name="z", init=10, width=12, comment=""),
                       ],
             ),

Any set values not of type int will not be swapped, so the following will work:

    SeqDI.SetDI("progB", set=dict(x=1, y=i2c["my_own_y"], z=10))

This adds the following to the DI file:

    Register(name="progB",
             type="int",
             mode="write",
             subregs=[ SubReg(name="x", init=1, width=1, comment=""),
                       SubReg(name="z", init=10,width=12, comment=""),
                       ],
             ),
"""
    def __init__(self, name, set, di_reg_name=None, **kw):
        """
:param name:        The name of this Sequence.
:param di_reg_name: The name of the register in the DI file.  If None, then the name of the sequence is used.
:param set:         See Seq.Set documentation
"""
        kw["name"] = name
        self.init = set
        newset = {}
        if di_reg_name:
            self.di_reg_name = di_reg_name
        else:
            self.di_reg_name = name

        self.dont_swap = []
        for k,v in set.items():
            if type(v) is int:
                # swap out the ints for i2c Signals
                newset[k] = Signal.Signal(name="%s_%s" % (self.di_reg_name, k,), width=1)
            else:
                self.dont_swap.append(k)
                newset[k] = v

        Seq.Set.__init__(self, newset, **kw)

    def link(self, sequencer, parent, data):
        subregs = []
        for k,v in self._set.items():
            if k in self.dont_swap: continue
            reg = sequencer.get_reg(k)
            subregs.append(DI.SubReg(name=k, init=self.init[k], width=reg.width, comment=""))
            v.width = reg.width

        if subregs:
            DI.addReg(hydro.i2c, DI.Register(name=self.di_reg_name, comment="Autogenerated Set register", type="int", mode="write", subregs=subregs))

        Seq.Set.link(self, sequencer, parent, data)
                             

class StallDI(Seq.Stall):
    """This Sequence extends the Seq.Stall Sequence and create a
programmable 'count' register in the DI file and will also swap a
static 'set' dict out for a completely programmable one whose default
settings are the original static dict (like SetDI).

Example:

    SeqDI.Stall(name="progA", count=100, di_count_reg="num_progA_stalls", width=10)

Is equivalent to:

    Seq.Stall(name="progA", count=i2c["num_progA_stalls"])

with the following in your DI file:

    Register(name="num_progA_stalls",
             type="int",
             mode="write",
             width=10,
             init=100,
             ),

Like SetDI, any static values in the set dict will also be swapped
for a programmable register.  Here is another example using:

    SeqDI.StallDI("progB", count=210, di_count_reg="num_progB_stalls", width=8, set=dict(x=1, y=0, z=10), di_reg_name="progB_set")

This is equivalent to:

    Seq.Stall("progB", count=i2c["num_progB_stalls"], set=dict(x=i2c["progB_set_x"], y=i2c["progB_set_y"], z=i2c["progB_set_z"])
)
    Register(name="num_progB_stalls",
             type="int",
             mode="write",
             width=8,
             init=210,
             ),
    Register(name="progB_set",
             type="int",
             mode="write",
             subregs=[ SubReg(name="x", init=1, width=1, comment=""),
                       SubReg(name="y", init=0, width=1, comment=""),
                       SubReg(name="z", init=10,width=12, comment=""),
                       ],
             ),
"""
    def __init__(self, name, count, width=None, di_count_reg=None, set={}, di_reg_name=None, **kw):
        """
:param name:        The name of this Sequence.
:param count:       An int for the default stall count.  This will get swapped out for an i2c register that resets to this value.
:param width:       The width you desire the 'count' i2c count register in bits.  If this is None, then the width will be automatically calculated to be the minimum number of bits necessary to hold the 'count' parameter.
:param di_count_reg: The name of the i2c register in the DI file.  If None, then it will be the sequence 'name' with the static string '_stall_count' appened to it.
:param set:         See SeqDI.SetDI and Seq.Set documentation
:param di_reg_name: The name of the register in the DI file that is associated with the 'set' dict.  If None, then the name of the sequence is used.
"""
        kw["name"] = name
        self.init = set
        newset = {}
        if di_reg_name:
            self.di_reg_name = di_reg_name
        else:
            self.di_reg_name = name
        if di_count_reg:
            self.di_count_reg = di_count_reg
        else:
            self.di_count_reg = name + "_stall_count"

        self.dont_swap = []
        for k,v in set.items():
            if type(v) is int:
                # swap out the ints for i2c Signals
                newset[k] = Signal.Signal(name="%s_%s" % (self.di_reg_name, k,), width=1)
            else:
                self.dont_swap.append(k)
                newset[k] = v

        if not(type(count) is int):
            raise Exception("count param must be of type int")

        if not width:
            width = Signal.calc_width(count)

        i2c_reg = DI.Register(name=self.di_count_reg, comment="Autogenerated Stall 'count' register", type="int", mode="write", init=count, width=width)
        DI.addReg(hydro.i2c, i2c_reg)

        newcount = Signal.Signal(name=self.di_count_reg, width=width, init=count)
        Seq.Stall.__init__(self, count=newcount, set=newset, **kw)

    def link(self, sequencer, parent, data):
        subregs = []
        for k,v in self._set.items():
            if k in self.dont_swap: continue
            reg = sequencer.get_reg(k)
            subregs.append(DI.SubReg(name=k, init=self.init[k], width=reg.width, comment=""))
            v.width = reg.width

        if subregs:
            DI.addReg(hydro.i2c, DI.Register(name=self.di_reg_name, comment="Autogenerated Stall set register", type="int", mode="write", subregs=subregs))

        if not(data.has_key(Seq.Stall)):
            data[Seq.Stall] = dict(insts=[])
        if not(data[Seq.Stall].has_key("insts")):
            data[Seq.Stall]["insts"] = []
        data[Seq.Stall]["insts"].append(self)

        Seq.Stall.link(self, sequencer, parent, data)


        

    @staticmethod
    def vlog_gen_static_logic(data):
        return [] # Seq.Stall will take care of it

class SerialDI(Seq.Serial):
    """This Sequence extends the Seq.Serial Sequence and will swap a
static serial sequence out for a completely programmable one whose
default settings are the original static sequence.  It adds registers
to the DI register list as necessary.  See Seq.Serial params.  A
termination register will be automatically added with a suffix '_stop_num'
in the  I2C register list.  Set this to the number of the last register
is used by this sequence to know when to terminate."""
    def __init__(self, name, subseqs, set={}, extra=0, di_reg_name=None, **kw):
        """:param extra: int. Number of extra sequences to append to the end of this sequence.
:param di_reg_name: The name of the register in the DI file.  If None, then the name of the sequence is used.
All other params are the same as the Seq.Serial Sequence"""

        kw["name"] = name
        self.init = subseqs
        newsubseqs = []
        if di_reg_name:
            self.di_reg_name = di_reg_name
        else:
            self.di_reg_name = name

        # create the termination Signal
        term = Signal.Signal(name="%s_term_num" % (self.di_reg_name,), width=Signal.calc_width(len(subseqs)+extra), init=len(subseqs)-1)

        for i, seq in enumerate(subseqs):
            if not(type(seq) is str):
                raise Exception("Cannot make Sequence %s programmable.  Only strings accepted in subseqs list for ProgSerial sequences" % str(seq))
            
            # swap out the strings for i2c Signals
            psig = Signal.Signal(name="%s_%s%d" % (self.di_reg_name, self.di_reg_name, i,), width=1)
            pseq = Seq.Child(sequence=psig)
            newsubseqs.append(pseq)

        for j in range(extra): # append any extra sequences specified
            i+=1
            newsubseqs.append(Seq.Child(sequence=Signal.Signal(name="%s_%s%d" % (self.di_reg_name, self.di_reg_name, i,), width=1)))
            self.init.append(0) # append address 0 as the initial condition for the extra registers

        Seq.Serial.__init__(self, newsubseqs, set, term, **kw)

    def link(self, sequencer, parent, data):
        # calculate the width of the programmable sequence
        if(len(sequencer.children) <= 1):
            self.sequencer_addr_width = 0
        else:
            self.sequencer_addr_width = int(Signal.calc_width(len(sequencer.children)))

        self.sequence_addr_width=1
        for child in sequencer.children:
            w = int(Signal.calc_width(len(child.seqs)))
            if(w > self.sequence_addr_width): self.sequence_addr_width = w

        # now that we know the size necessary for each program register, generate
        # a value map so we can program these registers by name
        self.valuemap = {}
        for j, child in enumerate(sequencer.children):
            for i, child_seq in enumerate(child.seqs):
                self.valuemap[child_seq.name] = (j << self.sequence_addr_width) + i

        
        self.sig_width = self.sequencer_addr_width + self.sequence_addr_width
        subregs = []
        for i, sig in enumerate(self.subseqs):
            s = sig.child_seq
            s.width = self.sig_width
            subregs.append(DI.SubReg(name=self.di_reg_name+str(i),
                                     init=self.init[i],
                                     width=self.sig_width,
                                     valuemap=self.valuemap,
                                     comment=""))

        subregs.append(DI.SubReg(name="term_num", 
                                width=self.term.width,
                                init=self.term.init,
                                comment="Autogenerated sequencer termination register for %s Sequence.  This number controls how many Sequences are executed" % (self.name,), 
                                ))


        reg = DI.Register(name=self.di_reg_name, 
                          comment="Autogenerated programmable sequences control for  Serial %s Sequence" % (self.name,), 
                          type="int", 
                          mode="write", 
                          subregs = subregs,
                          )

        DI.addReg(hydro.i2c, reg)



        Seq.Serial.link(self, sequencer, parent, data)
